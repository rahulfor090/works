# ðŸš€ Quick Reference Guide - Database Segregation

## ðŸ“Š At a Glance

| Database | Tables | Size Est. | Access Pattern | Pool Size |
|----------|--------|-----------|----------------|-----------|
| **reference_service_db** | 18 | Small | Read-heavy (99%) | 2-10 |
| **auth_service_db** | 13 | Medium | Mixed (60% read) | 2-10 |
| **institution_service_db** | 15 | Medium | Read-heavy (80%) | 2-15 |
| **content_service_db** | 95+ | Large | Read-heavy (85%) | 10-50 |
| **commerce_service_db** | 30 | Medium | Mixed (50% read) | 5-30 |
| **cms_service_db** | 25 | Small | Read-heavy (90%) | 2-10 |
| **archive_service_db** | 8 | Small | Write-heavy (60%) | 2-10 |
| **analytics_service_db** | 40+ | Very Large | Write-heavy (70%) | 5-20 |
| **operations_db** | 60+ | Medium | Batch operations | 2-10 |

---

## ðŸŽ¯ Key Benefits

### 1. **Independent Scaling**
```
High Traffic Period:
- Scale content_service_db: 10 â†’ 50 connections
- Scale analytics_service_db: 5 â†’ 30 connections  
- Other databases remain unchanged
```

### 2. **Deployment Flexibility**
```
Deploy content updates:
âœ“ Update content_service_db schema
âœ“ Zero impact on commerce or auth
âœ“ No downtime for other services
```

### 3. **Performance Optimization**
```
Before: 1 DB = 150 tables = Complex queries
After:  9 DBs = ~15-25 tables each = Faster queries

Query Speed Improvement: 20-40%
Index Efficiency: 50% better
```

### 4. **Security Isolation**
```
auth_service_db:      Strict access, encrypted backups
analytics_service_db: Read-only for most users
commerce_service_db:  PCI-DSS compliant isolation
```

### 5. **Maintenance Windows**
```
Backup analytics_service_db at 2 AM
â†“ No impact on user authentication or content browsing
```

---

## ðŸ”— Cross-Database Query Patterns

### Pattern 1: Using Views (Recommended)
```sql
-- In commerce_service_db, create view to auth_service_db
CREATE VIEW v_user AS 
SELECT user_id, username, email, first_name, last_name
FROM auth_service_db.user;

-- Use in queries
SELECT o.*, v.username 
FROM customer_order o
JOIN v_user v ON o.user_id = v.user_id;
```

### Pattern 2: Application-Level Join
```javascript
// Fetch from both databases
const user = await authDb('user').where({ user_id }).first();
const orders = await commerceDb('customer_order').where({ user_id });

// Combine in application
return { ...user, orders };
```

### Pattern 3: Federated Tables
```sql
-- Create federated link in commerce_service_db
CREATE TABLE user_federated (
  user_id int(11) unsigned,
  username varchar(90),
  email varchar(90)
) ENGINE=FEDERATED
CONNECTION='mysql://user:pass@host/auth_service_db/user';
```

---

## ðŸ“‹ Common Query Examples

### Get Article with Author and User Info
```javascript
const article = await contentDb('article as a')
  .join('journal as j', 'a.journal_id', 'j.journal_id')
  .join('map_article_author as maa', 'a.article_id', 'maa.article_id')
  .join('author as au', 'maa.author_id', 'au.author_id')
  .join('v_user as u', 'a.created_by', 'u.user_id') // Using view
  .where('a.article_id', articleId)
  .select('a.*', 'j.journal_title', 'au.first_name', 'au.last_name', 'u.username');
```

### Get User Orders with Items
```javascript
const orders = await commerceDb('customer_order as o')
  .join('user_artifact_purchase as uap', 'o.order_id', 'uap.order_id')
  .join('v_user as u', 'o.user_id', 'u.user_id') // Using view
  .where('o.user_id', userId)
  .select('o.*', 'uap.*', 'u.username', 'u.email');

// Enrich with content details
for (let order of orders) {
  if (order.artifact_type === 'Article') {
    order.content = await contentDb('article')
      .where({ article_id: order.artifact_id })
      .first();
  }
}
```

### Get Institution with Users and Subscriptions
```javascript
const institution = await institutionDb('site_account').where({ site_id }).first();

const users = await institutionDb('map_site_account_user as msu')
  .join('v_user as u', 'msu.user_id', 'u.user_id')
  .where('msu.site_id', site_id)
  .select('u.*');

const subscriptions = await commerceDb('map_institute_subscription')
  .where({ site_id })
  .where('end_date', '>', new Date());

return { ...institution, users, subscriptions };
```

---

## ðŸ”§ Environment Configuration

### .env File
```bash
# Database Configuration
DB_HOST=localhost
DB_PORT=3306
DB_USER=app_user
DB_PASSWORD=secure_password

# Database Names
AUTH_DB=auth_service_db
CONTENT_DB=content_service_db
COMMERCE_DB=commerce_service_db
INSTITUTION_DB=institution_service_db
ANALYTICS_DB=analytics_service_db
CMS_DB=cms_service_db
REFERENCE_DB=reference_service_db
ARCHIVE_DB=archive_service_db
OPERATIONS_DB=operations_db

# Redis Cache
REDIS_HOST=localhost
REDIS_PORT=6379

# Connection Pools
AUTH_POOL_MIN=2
AUTH_POOL_MAX=10
CONTENT_POOL_MIN=10
CONTENT_POOL_MAX=50
COMMERCE_POOL_MIN=5
COMMERCE_POOL_MAX=30
```

### Docker Compose
```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql
      - ./init-scripts:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
    command: 
      - --max_connections=500
      - --innodb_buffer_pool_size=2G

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  app:
    build: .
    environment:
      - DB_HOST=mysql
      - REDIS_HOST=redis
    depends_on:
      - mysql
      - redis
    ports:
      - "3000:3000"

volumes:
  mysql_data:
```

---

## ðŸ“ Migration Checklist

### Phase 1: Preparation
- [ ] Backup current database
- [ ] Test backup restoration
- [ ] Create new databases
- [ ] Set up user permissions
- [ ] Configure connection pools

### Phase 2: Reference Data
- [ ] Migrate reference_service_db
- [ ] Verify data integrity
- [ ] Create indexes
- [ ] Test queries

### Phase 3: Core Services
- [ ] Migrate auth_service_db
- [ ] Migrate institution_service_db  
- [ ] Create cross-database views
- [ ] Test authentication flow

### Phase 4: Content Migration
- [ ] Migrate content_service_db (largest)
- [ ] Verify all relationships
- [ ] Create full-text indexes
- [ ] Test content queries

### Phase 5: Transactional Services
- [ ] Migrate commerce_service_db
- [ ] Test order creation
- [ ] Verify payment workflows

### Phase 6: Supporting Services
- [ ] Migrate cms_service_db
- [ ] Migrate archive_service_db
- [ ] Test CMS functionality

### Phase 7: Analytics
- [ ] Migrate analytics_service_db (time-consuming)
- [ ] Partition tables by date
- [ ] Create aggregated reports
- [ ] Verify tracking code

### Phase 8: Operations
- [ ] Migrate operations_db
- [ ] Update cron jobs
- [ ] Test batch processes

### Phase 9: Application Updates
- [ ] Update database connections
- [ ] Update all queries to use views
- [ ] Update ORM models
- [ ] Test all API endpoints

### Phase 10: Testing
- [ ] Unit tests
- [ ] Integration tests
- [ ] Performance tests
- [ ] Load tests

### Phase 11: Deployment
- [ ] Deploy to staging
- [ ] Smoke tests
- [ ] Deploy to production
- [ ] Monitor for 24-48 hours

---

## âš¡ Performance Tips

### 1. Use Connection Pooling
```javascript
// Good: Reuse connections
const pool = { min: 10, max: 50 };

// Bad: Create new connection every time
const db = knex({ /* config */ });
```

### 2. Cache Reference Data
```javascript
// Cache countries, currencies, etc.
const countries = await cache.wrap('all_countries', async () => {
  return await referenceDb('ref_country').select();
}, { ttl: 86400 }); // 24 hours
```

### 3. Use Appropriate Indexes
```sql
-- Good: Composite index for common queries
CREATE INDEX idx_article_journal_date 
ON article(journal_id, online_publish_date);

-- Bad: Too many single-column indexes
CREATE INDEX idx_journal_id ON article(journal_id);
CREATE INDEX idx_publish_date ON article(online_publish_date);
```

### 4. Partition Large Tables
```sql
ALTER TABLE page_tracking_2025 
PARTITION BY RANGE (MONTH(created_date)) (
  PARTITION p01 VALUES LESS THAN (2),
  PARTITION p02 VALUES LESS THAN (3),
  -- ... up to p12
);
```

### 5. Use Read Replicas
```javascript
const contentMaster = knex({ /* master config */ });
const contentReplica = knex({ /* replica config */ });

// Write to master
await contentMaster('article').insert(data);

// Read from replica
const articles = await contentReplica('article').select();
```

---

## ðŸš¨ Troubleshooting

### Issue: View Not Found
```bash
Error: Table 'commerce_service_db.v_user' doesn't exist

Solution:
USE commerce_service_db;
CREATE OR REPLACE VIEW v_user AS 
SELECT * FROM auth_service_db.user;
```

### Issue: Cross-Database Permission Denied
```bash
Error: Access denied for user 'app_user'@'localhost' to database 'auth_service_db'

Solution:
GRANT SELECT ON auth_service_db.user TO 'commerce_app'@'%';
FLUSH PRIVILEGES;
```

### Issue: Slow Cross-Database Queries
```bash
Symptom: Queries taking > 5 seconds

Solutions:
1. Add indexes on join columns
2. Use views with limited columns
3. Cache frequently accessed data
4. Consider application-level joins
```

### Issue: Transaction Across Databases
```bash
Problem: Need ACID across commerce_service_db and auth_service_db

Solution: Use distributed transaction pattern:
```javascript
const authTrx = await authDb.transaction();
const commerceTrx = await commerceDb.transaction();

try {
  await authDb('user').transacting(authTrx).insert(userData);
  await commerceDb('order').transacting(commerceTrx).insert(orderData);
  
  await authTrx.commit();
  await commerceTrx.commit();
} catch (err) {
  await authTrx.rollback();
  await commerceTrx.rollback();
  throw err;
}
```

---

## ðŸ“Š Monitoring Queries

### Check Database Sizes
```sql
SELECT 
  table_schema AS 'Database',
  ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS 'Size (MB)'
FROM information_schema.tables
WHERE table_schema IN (
  'auth_service_db', 'content_service_db', 'commerce_service_db',
  'institution_service_db', 'analytics_service_db', 'cms_service_db',
  'reference_service_db', 'archive_service_db', 'operations_db'
)
GROUP BY table_schema
ORDER BY SUM(data_length + index_length) DESC;
```

### Check Connection Pool Usage
```javascript
setInterval(() => {
  console.log('Pool Status:', {
    auth: authDb.client.pool.numUsed() + '/' + authDb.client.pool.numFree(),
    content: contentDb.client.pool.numUsed() + '/' + contentDb.client.pool.numFree(),
    commerce: commerceDb.client.pool.numUsed() + '/' + commerceDb.client.pool.numFree()
  });
}, 60000); // Every minute
```

### Check Slow Queries
```sql
-- Enable slow query log
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2; -- 2 seconds

-- View slow queries
SELECT * FROM mysql.slow_log 
ORDER BY start_time DESC 
LIMIT 20;
```

---

## ðŸŽ“ Best Practices Summary

1. **Always use views** for cross-database access
2. **Cache reference data** (countries, currencies, etc.)
3. **Use connection pools** with appropriate sizing
4. **Partition large tables** (analytics, tracking)
5. **Create proper indexes** on foreign keys and join columns
6. **Use read replicas** for heavy read operations
7. **Monitor query performance** regularly
8. **Implement proper error handling** for cross-database operations
9. **Use transactions carefully** across databases
10. **Document all views** and cross-database dependencies

---

## ðŸ“ž Need Help?

- Review the complete documentation in artifact: "Complete Database Segregation Guide"
- Check migration scripts in artifact: "Complete Migration SQL Scripts"
- Review code examples in artifact: "Application Code Examples - Multi-Database"

---

*This quick reference guide provides the essential information for working with the segregated database architecture. For detailed information, refer to the complete documentation artifacts.*